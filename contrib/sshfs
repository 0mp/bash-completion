# sshfs(1) completion

have sshfs && have ssh &&
_sshfs()
{
    local cur userhost path

    COMPREPLY=()
    cur=`_get_cword ":"`

    _expand || return 0

    # things we want to backslash escape
    local esc="[][(){}<>\",:;^&\!$=?\`|\\ ']"

    if [[ "$cur" == *:* ]]; then
        local IFS=$'\t\n'
        # remove backslash escape from the first colon
        cur=${cur/\\:/:}
        userhost=${cur%%?(\\):*}
        path=${cur#*:}
        # unescape (3 backslashes to 1 for chars we escaped)
        path=$( sed -e 's/\\\\\\\('$esc'\)/\\\1/g' <<<"$path" )
        if [ -z "$path" ]; then
            # default to home dir of specified user on remote host
            path=$(ssh -o 'Batchmode yes' $userhost pwd 2>/dev/null)
        fi
        # escape spaces; remove executables, aliases, pipes and sockets;
        # add space at end of file names
        COMPREPLY=( $( ssh -o 'Batchmode yes' $userhost \
            command ls -aF1d "$path*" 2>/dev/null | \
            sed -e 's/'$esc'/\\\\\\&/g' -e 's/[*@|=]$//g' -e 's/[^\/]$/& /g' ) )
        return 0
    fi

    [[ "$cur" == */* ]] || _known_hosts_real -c -a "$cur"

    # This approach is used instead of _filedir to get a space appended
    # after local file/dir completions, and -o nospace retained for others.
    local IFS=$'\t\n'
    COMPREPLY=( "${COMPREPLY[@]}" $( command ls -aF1d $cur* 2>/dev/null | \
        sed -e "s/$esc/\\\\&/g" -e 's/[*@|=]$//g' -e 's/[^\/]$/& /g' ) )

    return 0
} &&
complete -F _sshfs -o nospace sshfs

# Local variables:
# mode: shell-script
# sh-basic-offset: 4
# sh-indent-comment: t
# indent-tabs-mode: nil
# End:
# ex: ts=4 sw=4 et filetype=sh
