# -*- mode: shell-script; sh-basic-offset: 8; indent-tabs-mode: t -*-
# ex: ts=8 sw=8 noet filetype=sh

# man(1) completion
#
[ $USERLAND = GNU -o $UNAME = Darwin \
  -o $UNAME = FreeBSD -o $UNAME = SunOS -o $UNAME = Cygwin \
  -o $UNAME = OpenBSD ] &&
_man()
{
	local cur i prev sect manpath manext mansect uname version subcommands

	manext="@([0-9lnp]|[0-9][px]|man|3pm)?(.@(gz|bz2|lzma))"
	mansect="@([0-9lnp]|[0-9][px]|3pm)"

	COMPREPLY=()
	cur=`_get_cword`
	prev=${COMP_WORDS[COMP_CWORD-1]}
	version=$(man --version | cut -d\  -f2)

	if [[ "$prev" == -l ]]; then
		_filedir $manext
		return 0
	fi

	_expand || return 0

	# file based completion if parameter contains /
	if [[ "$cur" == */* ]]; then
		_filedir $manext
		return 0
	fi

	uname=$( uname -s )
	if [[ $uname == @(Linux|GNU|GNU/*|FreeBSD|Cygwin|CYGWIN_*) ]]; then
		manpath=$( manpath 2>/dev/null || command man --path )
	else
		manpath=$MANPATH
	fi

	if [ -z "$manpath" ]; then
		COMPREPLY=( $( compgen -c -- $cur ) )
		return 0
	fi

	# determine manual section to search
	[[ "$prev" == $mansect ]] && sect=$prev || sect='*'

	manpath=$manpath:
	if [ -n "$cur" ]; then
		manpath="${manpath//://*man$sect/$cur* } ${manpath//://*cat$sect/$cur* }"
	else
		manpath="${manpath//://*man$sect/ } ${manpath//://*cat$sect/ }"
	fi

	# Check whether $prev has "subcommand" manpages -- not always right! (try man hg ssh, then $ hg ssh)
	# Unfortunately, there's no way to check whether a completion is a valid subcommand or not.
	# man cmd subcmd is only supported from man-db 2.5.6
	if ([ ${version:0:1} -eq 2 ] && [ ${version:2:1} -eq 5 ] && [ ${version:4:1} -gt 5 ]) ||
	   ([ ${version:0:1} -eq 2 ] && [ ${version:2:1} -gt 5 ]) ||
	   [ ${version:0:1} -gt 2 ]; then
		subcommands=$(whatis -w "$prev-*" | awk '{print $1}' | sed -e "s/$prev-//g" | tr "\n" " ")
		if [ -n "$subcommands" ]; then
			COMPREPLY=( $( compgen -W "$subcommands" -- $cur ) )
			return 0
		fi
	fi

	# redirect stderr for when path doesn't exist
	COMPREPLY=( $( eval command ls "$manpath" 2>/dev/null ) )
	# weed out directory path names and paths to man pages
	COMPREPLY=( ${COMPREPLY[@]##*/?(:)} )
	# strip suffix from man pages
	COMPREPLY=( ${COMPREPLY[@]%.@(gz|bz2|lzma)} )
	COMPREPLY=( $( compgen -W '${COMPREPLY[@]%.*}' -- "${cur//\\\\/}" ) )

	if [[ "$prev" != $mansect ]]; then
		# File based completion for the rest, prepending ./ if needed
		# (man 1.6f needs that for man pages in current dir)
		local start=${#COMPREPLY[@]}
		_filedir $manext
		for (( i=$start; i < ${#COMPREPLY[@]}; i++ )); do
			[[ ${COMPREPLY[i]} == */* ]] || COMPREPLY[i]=./${COMPREPLY[i]}
		done
	fi

	return 0
}
[ $USERLAND = GNU -o $UNAME = Darwin \
  -o $UNAME = FreeBSD -o $UNAME = SunOS -o $UNAME = Cygwin \
  -o $UNAME = OpenBSD ] && \
complete -F _man $filenames man apropos whatis
